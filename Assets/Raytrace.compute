#pragma kernel main

#define WORKGROUP_SIZE_X 8
#define WORKGROUP_SIZE_Y 8

#define EPSILON 0.0001

//-------------------------//

RWTexture2D<float4> u_outTexture;
uint2 u_outTextureDims;

float4x4 u_invView;
float4x4 u_invProj;

uint3 u_volumeSize;

//-------------------------//

float2 intersect_aabb(float3 boxMin, float3 boxMax, float3 rayPos, float3 invRayDir)
{
	float3 tMin = (boxMin - rayPos) * invRayDir;
	float3 tMax = (boxMax - rayPos) * invRayDir;

	float3 t1 = min(tMin, tMax);
	float3 t2 = max(tMin, tMax);

	float tNear = max(max(t1.x, t1.y), t1.z);
	float tFar = min(min(t2.x, t2.y), t2.z);

	return float2(tNear, tFar);
}

float3 background_color(float3 rayDir)
{
	float a = rayDir.y * 0.5 + 0.5;
	return lerp(float3(0.71, 0.85, 0.90), float3(0.00, 0.45, 0.74), a);
}

//-------------------------//

bool in_bounds(uint3 pos)
{
	return pos.x < u_volumeSize.x && pos.y < u_volumeSize.y && pos.z < u_volumeSize.z;
}

bool voxel_exists(uint3 pos)
{
	float3 normPos = float3(pos) / float3(u_volumeSize);
	normPos *= 2.0;
	normPos -= 1.0;

	return dot(normPos, normPos) < 1.0;

	/*let idx = pos.x + u_renderParams.volumeSize.x * (pos.y + u_renderParams.volumeSize.y * pos.z);
	let arrIdx = idx / 32;
	let bitIdx = idx % 32;

	return (u_voxelBitmap[arrIdx] & (1u << bitIdx)) != 0;*/
}

float3 get_voxel_color(uint3 pos)
{
	return float3(pos) / float3(u_volumeSize);

	/*let idx = pos.x + u_renderParams.volumeSize.x * (pos.y + u_renderParams.volumeSize.y * pos.z);
	let packedColor = u_voxelData[idx];

	let r = (packedColor >> 24) & 0xFF;
	let g = (packedColor >> 16) & 0xFF;
	let b = (packedColor >> 8) & 0xFF;

	return vec3f(f32(r) / 255.0, f32(g) / 255.0, f32(b) / 255.0);*/
}

struct IntersectVolumeOut
{
	bool hit;
	float3 color;
};

//simple DDA voxel traversal algorithm
//http://www.cse.yorku.ca/~amana/research/grid.pdf
//https://www.shadertoy.com/view/4dX3zl
IntersectVolumeOut intersect_volume(float3 rayPos, float3 rayDir, float3 invRayDir)
{
	float3 localRayPos = rayPos * float3(u_volumeSize);

	uint3 mapPos = uint3(floor(localRayPos));
	float3 deltaDist = abs(invRayDir);
	int3 step = int3(sign(rayDir));
	float3 sideDist = (sign(rayDir) * (float3(mapPos) - localRayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist;
	float3 lastSideDist = float3(0.0, 0.0, 0.0);

	bool hit = false;
	while(in_bounds(mapPos))
	{
		if(voxel_exists(mapPos))
		{
			hit = true;
			break;
		}

		lastSideDist = sideDist;

		if(sideDist.x < sideDist.y)
		{
			if(sideDist.x < sideDist.z)
			{
				sideDist.x += deltaDist.x;
				mapPos.x += (uint)step.x;
			}
			else
			{
				sideDist.z += deltaDist.z;
				mapPos.z += (uint)step.z;
			}
		}
		else
		{
			if(sideDist.y < sideDist.z)
			{
				sideDist.y += deltaDist.y;
				mapPos.y += (uint)step.y;
			}
			else
			{
				sideDist.z += deltaDist.z;
				mapPos.z += (uint)step.z;
			}
		}
	}

	IntersectVolumeOut retval;
	retval.hit = hit;
	if(hit)
		retval.color = get_voxel_color(mapPos);
	else
		retval.color = float3(0.0, 0.0, 0.0);

	return retval;
}

//-------------------------//

[numthreads(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)]
void main(uint3 id : SV_DispatchThreadID)
{
    //skip pixels out of texture bounds (happens due to workgroup size):
	//---------------
    uint2 writePos = id.xy;
    if(writePos.x >= u_outTextureDims.x || writePos.y >= u_outTextureDims.y)
        return;

    //generate ray pos + dir:
	//---------------
    float2 pixelCenter = float2((float)writePos.x, (float)writePos.y) + float2(0.5, 0.5);
    float2 uv = pixelCenter / float2(u_outTextureDims);
	float2 d = uv * 2.0 - 1.0;

	float4 rayPos4 = mul(u_invView, float4(0.0, 0.0, 0.0, 1.0));
	float4 rayTarget = mul(u_invProj, float4(d.x, d.y, 1.0, 1.0));

	float4 rayDir4 = mul(u_invView, float4(normalize(rayTarget.xyz), 0.0));

	float3 rayPos = rayPos4.xyz;
	float3 rayDir = normalize(rayDir4.xyz);
    float3 invRayDir = 1.0 / rayDir;

	//check for intersection with bounding cube:
	//---------------
    uint maxSize = max(max(u_volumeSize.x, u_volumeSize.y), u_volumeSize.z);
	float3 volumeMin = -float3(u_volumeSize) / (float)maxSize;
	float3 volumeMax =  float3(u_volumeSize) / (float)maxSize;

	float2 intersect = intersect_aabb(volumeMin, volumeMax, rayPos, invRayDir);

    //trace ray through volume (TODO):
	//---------------    
    float3 color;
    if(intersect.x > intersect.y || intersect.y < 0.0)
        color = background_color(rayDir);
    else
	{
		float3 startRayPos = rayPos;
		if(intersect.x > 0.0)
			startRayPos += rayDir * (intersect.x + EPSILON);

		startRayPos -= volumeMin;
		startRayPos /= (volumeMax - volumeMin);

		IntersectVolumeOut result = intersect_volume(startRayPos, rayDir, invRayDir);

		if(result.hit)
			color = result.color;
		else
			color = background_color(rayDir);
	}

    //write final color:
	//---------------
    u_outTexture[writePos] = float4(color, 1.0);
}
